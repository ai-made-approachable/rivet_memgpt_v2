import {} from '../NodeBase.js';
import { NodeImpl } from '../NodeImpl.js';
import { nodeDefinition } from '../NodeDefinition.js';
import {} from '../GraphProcessor.js';
import {} from '../NodeGraph.js';
import { nanoid } from 'nanoid/non-secure';
import {} from '../Project.js';
import {} from './GraphInputNode.js';
import {} from './GraphOutputNode.js';
import {} from '../DataValue.js';
import {} from '../ProcessContext.js';
import {} from '../../index.js';
import { dedent } from 'ts-dedent';
import { getError } from '../../utils/errors.js';
import { match } from 'ts-pattern';
export class SubGraphNodeImpl extends NodeImpl {
    static create() {
        const chartNode = {
            type: 'subGraph',
            title: 'Subgraph',
            id: nanoid(),
            visualData: {
                x: 0,
                y: 0,
                width: 300,
            },
            data: {
                graphId: '',
                useErrorOutput: false,
                useAsGraphPartialOutput: false,
            },
        };
        return chartNode;
    }
    getInputDefinitions(_connections, _nodes, project) {
        const graph = project.graphs[this.data.graphId];
        if (!graph) {
            return [];
        }
        const inputNodes = graph.nodes.filter((node) => node.type === 'graphInput');
        const inputIds = [...new Set(inputNodes.map((node) => node.data.id))].sort();
        return inputIds.map((id) => ({
            id: id,
            title: id,
            dataType: inputNodes.find((node) => node.data.id === id).data.dataType,
        }));
    }
    getGraphOutputs(project) {
        const graph = project.graphs[this.data.graphId];
        if (!graph) {
            return [];
        }
        const outputNodes = graph.nodes.filter((node) => node.type === 'graphOutput');
        const outputIds = [...new Set(outputNodes.map((node) => node.data.id))].sort();
        const outputs = outputIds.map((id) => ({
            id: id,
            title: id,
            dataType: outputNodes.find((node) => node.data.id === id).data.dataType,
        }));
        return outputs;
    }
    getOutputDefinitions(_connections, _nodes, project) {
        const outputs = [];
        outputs.push(...this.getGraphOutputs(project));
        if (this.data.useErrorOutput) {
            outputs.push({
                id: 'error',
                title: 'Error',
                dataType: 'string',
            });
        }
        return outputs;
    }
    getEditors(context) {
        const definitions = [
            {
                type: 'graphSelector',
                label: 'Graph',
                dataKey: 'graphId',
            },
            {
                type: 'toggle',
                label: 'Use Error Output',
                dataKey: 'useErrorOutput',
            },
        ];
        if (this.data.graphId) {
            const graph = context.project.graphs[this.data.graphId];
            if (graph) {
                const inputNodes = graph.nodes.filter((node) => node.type === 'graphInput');
                const inputIds = [...new Set(inputNodes.map((node) => node.data.id))].sort();
                for (const inputId of inputIds) {
                    const inputNode = inputNodes.find((node) => node.data.id === inputId);
                    definitions.push({
                        type: 'dynamic',
                        dataKey: 'inputData',
                        dynamicDataKey: inputNode.data.id,
                        dataType: inputNode.data.dataType,
                        label: inputNode.data.id,
                        editor: inputNode.data.editor ?? 'auto',
                    });
                }
            }
        }
        return definitions;
    }
    static getUIData() {
        return {
            infoBoxBody: dedent `
        Executes another graph. Inputs and outputs are defined by Graph Input and Graph Output nodes within the subgraph.
      `,
            infoBoxTitle: 'Subgraph Node',
            contextMenuTitle: 'Subgraph',
            group: ['Advanced'],
        };
    }
    async process(inputs, context) {
        const { project } = context;
        if (!project) {
            throw new Error('SubGraphNode requires a project to be set in the context.');
        }
        const graph = project.graphs[this.data.graphId];
        if (!graph) {
            throw new Error(`SubGraphNode requires a graph with id ${this.data.graphId} to be present in the project.`);
        }
        const inputNodes = graph.nodes.filter((node) => node.type === 'graphInput');
        const inputIds = [...new Set(inputNodes.map((node) => node.data.id))].sort();
        const inputData = inputIds.reduce((obj, id) => {
            if (inputs[id] != null) {
                return {
                    ...obj,
                    [id]: inputs[id],
                };
            }
            if (this.data.inputData?.[id] != null) {
                return {
                    ...obj,
                    [id]: this.data.inputData[id],
                };
            }
            return obj;
        }, {});
        const subGraphProcessor = context.createSubProcessor(this.data.graphId, { signal: context.signal });
        try {
            const startTime = Date.now();
            const outputs = await subGraphProcessor.processGraph(context, inputData, context.contextValues);
            const duration = Date.now() - startTime;
            if (this.data.useErrorOutput) {
                outputs['error'] = {
                    type: 'control-flow-excluded',
                    value: undefined,
                };
            }
            if (outputs['duration'] == null) {
                outputs['duration'] = {
                    type: 'number',
                    value: duration,
                };
            }
            return outputs;
        }
        catch (err) {
            if (!this.data.useErrorOutput) {
                throw err;
            }
            const outputs = this.getGraphOutputs(context.project).reduce((obj, output) => ({
                ...obj,
                [output.id]: {
                    type: 'control-flow-excluded',
                    value: undefined,
                },
            }), {});
            outputs['error'] = {
                type: 'string',
                value: getError(err).message,
            };
            return outputs;
        }
    }
}
export const subGraphNode = nodeDefinition(SubGraphNodeImpl, 'Subgraph');
