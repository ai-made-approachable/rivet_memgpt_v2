import { type DataValue, type ArrayDataValue, type AnyDataValue, type StringArrayDataValue, type ControlFlowExcludedDataValue, type ScalarOrArrayDataValue } from './DataValue.js';
import type { ChartNode, NodeConnection, NodeId, PortId } from './NodeBase.js';
import type { GraphId, NodeGraph } from './NodeGraph.js';
import type { UserInputNode } from './nodes/UserInputNode.js';
import type { Project } from './Project.js';
import type { InternalProcessContext, ProcessContext, ProcessId } from './ProcessContext.js';
import type { ExecutionRecorder } from '../recording/ExecutionRecorder.js';
import type { Opaque } from 'type-fest';
import type { NodeRegistration } from './NodeRegistration.js';
export type ProcessEvents = {
    /** Called when processing has started. */
    start: {
        project: Project;
        startGraph: NodeGraph;
        inputs: GraphInputs;
        contextValues: Record<string, DataValue>;
    };
    /** Called when a graph or subgraph has started. */
    graphStart: {
        graph: NodeGraph;
        inputs: GraphInputs;
    };
    /** Called when a graph or subgraph has errored. */
    graphError: {
        graph: NodeGraph;
        error: Error | string;
    };
    /** Called when a graph or a subgraph has finished. */
    graphFinish: {
        graph: NodeGraph;
        outputs: GraphOutputs;
    };
    /** Called when a graph has been aborted. */
    graphAbort: {
        successful: boolean;
        graph: NodeGraph;
        error?: Error | string;
    };
    /** Called when a node has started processing, with the input values for the node. */
    nodeStart: {
        node: ChartNode;
        inputs: Inputs;
        processId: ProcessId;
    };
    /** Called when a node has finished processing, with the output values for the node. */
    nodeFinish: {
        node: ChartNode;
        outputs: Outputs;
        processId: ProcessId;
    };
    /** Called when a node has errored during processing. */
    nodeError: {
        node: ChartNode;
        error: Error | string;
        processId: ProcessId;
    };
    /** Called when a node has been excluded from processing. */
    nodeExcluded: {
        node: ChartNode;
        processId: ProcessId;
        inputs: Inputs;
        outputs: Outputs;
        reason: string;
    };
    /** Called when a user input node requires user input. Call the callback when finished, or call userInput() on the GraphProcessor with the results. */
    userInput: {
        node: UserInputNode;
        inputs: Inputs;
        callback: (values: StringArrayDataValue) => void;
        processId: ProcessId;
    };
    /** Called when a node has partially processed, with the current partial output values for the node. */
    partialOutput: {
        node: ChartNode;
        outputs: Outputs;
        index: number;
        processId: ProcessId;
    };
    /** Called when the outputs of a node have been cleared entirely. If processId is present, only the one process() should be cleared. */
    nodeOutputsCleared: {
        node: ChartNode;
        processId?: ProcessId;
    };
    /** Called when the root graph has errored. The root graph will also throw. */
    error: {
        error: Error | string;
    };
    /** Called when processing has completed. */
    done: {
        results: GraphOutputs;
    };
    /** Called when processing has been aborted. */
    abort: {
        successful: boolean;
        error?: string | Error;
    };
    /** Called when processing has finished either successfully or unsuccessfully. */
    finish: void;
    /** Called for trace level logs. */
    trace: string;
    /** Called when the graph has been paused. */
    pause: void;
    /** Called when the graph has been resumed. */
    resume: void;
    /** Called when a global variable has been set in a graph. */
    globalSet: {
        id: string;
        value: ScalarOrArrayDataValue;
        processId: ProcessId;
    };
    /** Called when an AbortController has been created. Used by node to increase the max event listeners. */
    newAbortController: AbortController;
} & {
    /** Listen for any user event. */
    [key: `userEvent:${string}`]: DataValue | undefined;
} & {
    [key: `globalSet:${string}`]: ScalarOrArrayDataValue | undefined;
};
export type ProcessEvent = {
    [P in keyof ProcessEvents]: {
        type: P;
    } & ProcessEvents[P];
}[keyof ProcessEvents];
export type GraphOutputs = Record<string, DataValue>;
export type GraphInputs = Record<string, DataValue>;
export type NodeResults = Map<NodeId, Outputs>;
export type Inputs = Record<PortId, DataValue | undefined>;
export type Outputs = Record<PortId, DataValue | undefined>;
export type ExternalFunctionProcessContext = Omit<InternalProcessContext, 'setGlobal'>;
export type ExternalFunction = (context: ExternalFunctionProcessContext, ...args: unknown[]) => Promise<DataValue & {
    cost?: number;
}>;
export type RaceId = Opaque<string, 'RaceId'>;
export type LoopInfo = AttachedNodeDataItem & {
    /** ID of the controller of the loop */
    loopControllerId: NodeId;
    /** Nodes add themselves to this as the loop processes */
    nodes: Set<NodeId>;
    iterationCount: number;
};
export type AttachedNodeDataItem = {
    propagate: boolean | ((parent: ChartNode, connections: NodeConnection[]) => boolean);
};
export type AttachedNodeData = {
    loopInfo?: LoopInfo;
    races?: {
        propagate: boolean;
        raceIds: RaceId[];
        completed: boolean;
    };
    [key: string]: AttachedNodeDataItem | undefined;
};
export declare class GraphProcessor {
    #private;
    slowMode: boolean;
    id: string;
    executor?: 'nodejs' | 'browser';
    /** If set, specifies the node(s) that the graph will run TO, instead of the nodes without any dependents. */
    runToNodeIds?: NodeId[];
    /** The interval between nodeFinish events when playing back a recording. I.e. how fast the playback is. */
    recordingPlaybackChatLatency: number;
    warnOnInvalidGraph: boolean;
    get isRunning(): boolean;
    constructor(project: Project, graphId?: GraphId, registry?: NodeRegistration);
    on: <Name extends "done" | "error" | "userInput" | `userEvent:${string}` | `globalSet:${string}` | "start" | "graphStart" | "graphError" | "graphFinish" | "graphAbort" | "nodeStart" | "nodeFinish" | "nodeError" | "nodeExcluded" | "partialOutput" | "nodeOutputsCleared" | "abort" | "finish" | "trace" | "pause" | "resume" | "globalSet" | "newAbortController" | keyof import("emittery").OmnipresentEventData>(eventName: Name | readonly Name[], listener: (eventData: ({
        /** Called when processing has started. */
        start: {
            project: Project;
            startGraph: NodeGraph;
            inputs: GraphInputs;
            contextValues: Record<string, DataValue>;
        };
        /** Called when a graph or subgraph has started. */
        graphStart: {
            graph: NodeGraph;
            inputs: GraphInputs;
        };
        /** Called when a graph or subgraph has errored. */
        graphError: {
            graph: NodeGraph;
            error: string | Error;
        };
        /** Called when a graph or a subgraph has finished. */
        graphFinish: {
            graph: NodeGraph;
            outputs: GraphOutputs;
        };
        /** Called when a graph has been aborted. */
        graphAbort: {
            successful: boolean;
            graph: NodeGraph;
            error?: string | Error | undefined;
        };
        /** Called when a node has started processing, with the input values for the node. */
        nodeStart: {
            node: ChartNode;
            inputs: Inputs;
            processId: ProcessId;
        };
        /** Called when a node has finished processing, with the output values for the node. */
        nodeFinish: {
            node: ChartNode;
            outputs: Outputs;
            processId: ProcessId;
        };
        /** Called when a node has errored during processing. */
        nodeError: {
            node: ChartNode;
            error: string | Error;
            processId: ProcessId;
        };
        /** Called when a node has been excluded from processing. */
        nodeExcluded: {
            node: ChartNode;
            processId: ProcessId;
            inputs: Inputs;
            outputs: Outputs;
            reason: string;
        };
        /** Called when a user input node requires user input. Call the callback when finished, or call userInput() on the GraphProcessor with the results. */
        userInput: {
            node: UserInputNode;
            inputs: Inputs;
            callback: (values: StringArrayDataValue) => void;
            processId: ProcessId;
        };
        /** Called when a node has partially processed, with the current partial output values for the node. */
        partialOutput: {
            node: ChartNode;
            outputs: Outputs;
            index: number;
            processId: ProcessId;
        };
        /** Called when the outputs of a node have been cleared entirely. If processId is present, only the one process() should be cleared. */
        nodeOutputsCleared: {
            node: ChartNode;
            processId?: ProcessId | undefined;
        };
        /** Called when the root graph has errored. The root graph will also throw. */
        error: {
            error: string | Error;
        };
        /** Called when processing has completed. */
        done: {
            results: GraphOutputs;
        };
        /** Called when processing has been aborted. */
        abort: {
            successful: boolean;
            error?: string | Error | undefined;
        };
        /** Called when processing has finished either successfully or unsuccessfully. */
        finish: void;
        /** Called for trace level logs. */
        trace: string;
        /** Called when the graph has been paused. */
        pause: void;
        /** Called when the graph has been resumed. */
        resume: void;
        /** Called when a global variable has been set in a graph. */
        globalSet: {
            id: string;
            value: ScalarOrArrayDataValue;
            processId: ProcessId;
        };
        /** Called when an AbortController has been created. Used by node to increase the max event listeners. */
        newAbortController: AbortController;
    } & {
        [key: `userEvent:${string}`]: DataValue | undefined;
    } & {
        [key: `globalSet:${string}`]: ScalarOrArrayDataValue | undefined;
    } & import("emittery").OmnipresentEventData)[Name]) => void | Promise<void>) => import("emittery").UnsubscribeFunction;
    off: <Name extends "done" | "error" | "userInput" | `userEvent:${string}` | `globalSet:${string}` | "start" | "graphStart" | "graphError" | "graphFinish" | "graphAbort" | "nodeStart" | "nodeFinish" | "nodeError" | "nodeExcluded" | "partialOutput" | "nodeOutputsCleared" | "abort" | "finish" | "trace" | "pause" | "resume" | "globalSet" | "newAbortController" | keyof import("emittery").OmnipresentEventData>(eventName: Name | readonly Name[], listener: (eventData: ({
        /** Called when processing has started. */
        start: {
            project: Project;
            startGraph: NodeGraph;
            inputs: GraphInputs;
            contextValues: Record<string, DataValue>;
        };
        /** Called when a graph or subgraph has started. */
        graphStart: {
            graph: NodeGraph;
            inputs: GraphInputs;
        };
        /** Called when a graph or subgraph has errored. */
        graphError: {
            graph: NodeGraph;
            error: string | Error;
        };
        /** Called when a graph or a subgraph has finished. */
        graphFinish: {
            graph: NodeGraph;
            outputs: GraphOutputs;
        };
        /** Called when a graph has been aborted. */
        graphAbort: {
            successful: boolean;
            graph: NodeGraph;
            error?: string | Error | undefined;
        };
        /** Called when a node has started processing, with the input values for the node. */
        nodeStart: {
            node: ChartNode;
            inputs: Inputs;
            processId: ProcessId;
        };
        /** Called when a node has finished processing, with the output values for the node. */
        nodeFinish: {
            node: ChartNode;
            outputs: Outputs;
            processId: ProcessId;
        };
        /** Called when a node has errored during processing. */
        nodeError: {
            node: ChartNode;
            error: string | Error;
            processId: ProcessId;
        };
        /** Called when a node has been excluded from processing. */
        nodeExcluded: {
            node: ChartNode;
            processId: ProcessId;
            inputs: Inputs;
            outputs: Outputs;
            reason: string;
        };
        /** Called when a user input node requires user input. Call the callback when finished, or call userInput() on the GraphProcessor with the results. */
        userInput: {
            node: UserInputNode;
            inputs: Inputs;
            callback: (values: StringArrayDataValue) => void;
            processId: ProcessId;
        };
        /** Called when a node has partially processed, with the current partial output values for the node. */
        partialOutput: {
            node: ChartNode;
            outputs: Outputs;
            index: number;
            processId: ProcessId;
        };
        /** Called when the outputs of a node have been cleared entirely. If processId is present, only the one process() should be cleared. */
        nodeOutputsCleared: {
            node: ChartNode;
            processId?: ProcessId | undefined;
        };
        /** Called when the root graph has errored. The root graph will also throw. */
        error: {
            error: string | Error;
        };
        /** Called when processing has completed. */
        done: {
            results: GraphOutputs;
        };
        /** Called when processing has been aborted. */
        abort: {
            successful: boolean;
            error?: string | Error | undefined;
        };
        /** Called when processing has finished either successfully or unsuccessfully. */
        finish: void;
        /** Called for trace level logs. */
        trace: string;
        /** Called when the graph has been paused. */
        pause: void;
        /** Called when the graph has been resumed. */
        resume: void;
        /** Called when a global variable has been set in a graph. */
        globalSet: {
            id: string;
            value: ScalarOrArrayDataValue;
            processId: ProcessId;
        };
        /** Called when an AbortController has been created. Used by node to increase the max event listeners. */
        newAbortController: AbortController;
    } & {
        [key: `userEvent:${string}`]: DataValue | undefined;
    } & {
        [key: `globalSet:${string}`]: ScalarOrArrayDataValue | undefined;
    } & import("emittery").OmnipresentEventData)[Name]) => void | Promise<void>) => void;
    once: <Name extends "done" | "error" | "userInput" | `userEvent:${string}` | `globalSet:${string}` | "start" | "graphStart" | "graphError" | "graphFinish" | "graphAbort" | "nodeStart" | "nodeFinish" | "nodeError" | "nodeExcluded" | "partialOutput" | "nodeOutputsCleared" | "abort" | "finish" | "trace" | "pause" | "resume" | "globalSet" | "newAbortController" | keyof import("emittery").OmnipresentEventData>(eventName: Name | readonly Name[]) => import("emittery").EmitteryOncePromise<({
        /** Called when processing has started. */
        start: {
            project: Project;
            startGraph: NodeGraph;
            inputs: GraphInputs;
            contextValues: Record<string, DataValue>;
        };
        /** Called when a graph or subgraph has started. */
        graphStart: {
            graph: NodeGraph;
            inputs: GraphInputs;
        };
        /** Called when a graph or subgraph has errored. */
        graphError: {
            graph: NodeGraph;
            error: string | Error;
        };
        /** Called when a graph or a subgraph has finished. */
        graphFinish: {
            graph: NodeGraph;
            outputs: GraphOutputs;
        };
        /** Called when a graph has been aborted. */
        graphAbort: {
            successful: boolean;
            graph: NodeGraph;
            error?: string | Error | undefined;
        };
        /** Called when a node has started processing, with the input values for the node. */
        nodeStart: {
            node: ChartNode;
            inputs: Inputs;
            processId: ProcessId;
        };
        /** Called when a node has finished processing, with the output values for the node. */
        nodeFinish: {
            node: ChartNode;
            outputs: Outputs;
            processId: ProcessId;
        };
        /** Called when a node has errored during processing. */
        nodeError: {
            node: ChartNode;
            error: string | Error;
            processId: ProcessId;
        };
        /** Called when a node has been excluded from processing. */
        nodeExcluded: {
            node: ChartNode;
            processId: ProcessId;
            inputs: Inputs;
            outputs: Outputs;
            reason: string;
        };
        /** Called when a user input node requires user input. Call the callback when finished, or call userInput() on the GraphProcessor with the results. */
        userInput: {
            node: UserInputNode;
            inputs: Inputs;
            callback: (values: StringArrayDataValue) => void;
            processId: ProcessId;
        };
        /** Called when a node has partially processed, with the current partial output values for the node. */
        partialOutput: {
            node: ChartNode;
            outputs: Outputs;
            index: number;
            processId: ProcessId;
        };
        /** Called when the outputs of a node have been cleared entirely. If processId is present, only the one process() should be cleared. */
        nodeOutputsCleared: {
            node: ChartNode;
            processId?: ProcessId | undefined;
        };
        /** Called when the root graph has errored. The root graph will also throw. */
        error: {
            error: string | Error;
        };
        /** Called when processing has completed. */
        done: {
            results: GraphOutputs;
        };
        /** Called when processing has been aborted. */
        abort: {
            successful: boolean;
            error?: string | Error | undefined;
        };
        /** Called when processing has finished either successfully or unsuccessfully. */
        finish: void;
        /** Called for trace level logs. */
        trace: string;
        /** Called when the graph has been paused. */
        pause: void;
        /** Called when the graph has been resumed. */
        resume: void;
        /** Called when a global variable has been set in a graph. */
        globalSet: {
            id: string;
            value: ScalarOrArrayDataValue;
            processId: ProcessId;
        };
        /** Called when an AbortController has been created. Used by node to increase the max event listeners. */
        newAbortController: AbortController;
    } & {
        [key: `userEvent:${string}`]: DataValue | undefined;
    } & {
        [key: `globalSet:${string}`]: ScalarOrArrayDataValue | undefined;
    } & import("emittery").OmnipresentEventData)[Name]>;
    onAny: (listener: (eventName: "done" | "error" | "userInput" | `userEvent:${string}` | `globalSet:${string}` | "start" | "graphStart" | "graphError" | "graphFinish" | "graphAbort" | "nodeStart" | "nodeFinish" | "nodeError" | "nodeExcluded" | "partialOutput" | "nodeOutputsCleared" | "abort" | "finish" | "trace" | "pause" | "resume" | "globalSet" | "newAbortController", eventData: string | void | import("./DataValue.js").StringDataValue | import("./DataValue.js").NumberDataValue | import("./DataValue.js").DateDataValue | import("./DataValue.js").TimeDataValue | import("./DataValue.js").DateTimeDataValue | import("./DataValue.js").BoolDataValue | import("./DataValue.js").ChatMessageDataValue | ControlFlowExcludedDataValue | AnyDataValue | import("./DataValue.js").ObjectDataValue | import("./DataValue.js").GptFunctionDataValue | import("./DataValue.js").VectorDataValue | import("./DataValue.js").ImageDataValue | import("./DataValue.js").BinaryDataValue | import("./DataValue.js").AudioDataValue | ArrayDataValue<import("./DataValue.js").StringDataValue> | ArrayDataValue<import("./DataValue.js").NumberDataValue> | ArrayDataValue<import("./DataValue.js").BoolDataValue> | ArrayDataValue<import("./DataValue.js").ObjectDataValue> | ArrayDataValue<import("./DataValue.js").DateDataValue> | ArrayDataValue<import("./DataValue.js").TimeDataValue> | ArrayDataValue<import("./DataValue.js").DateTimeDataValue> | ArrayDataValue<import("./DataValue.js").ChatMessageDataValue> | ArrayDataValue<ControlFlowExcludedDataValue> | ArrayDataValue<AnyDataValue> | ArrayDataValue<import("./DataValue.js").GptFunctionDataValue> | ArrayDataValue<import("./DataValue.js").VectorDataValue> | ArrayDataValue<import("./DataValue.js").ImageDataValue> | ArrayDataValue<import("./DataValue.js").BinaryDataValue> | ArrayDataValue<import("./DataValue.js").AudioDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").StringDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").NumberDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").BoolDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").ObjectDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").DateDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").TimeDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").DateTimeDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").ChatMessageDataValue> | import("./DataValue.js").FunctionDataValue<ControlFlowExcludedDataValue> | import("./DataValue.js").FunctionDataValue<AnyDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").GptFunctionDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").VectorDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").ImageDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").BinaryDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").AudioDataValue> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").StringDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").NumberDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").BoolDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").ObjectDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").DateDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").TimeDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").DateTimeDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").ChatMessageDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<ControlFlowExcludedDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<AnyDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").GptFunctionDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").VectorDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").ImageDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").BinaryDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").AudioDataValue>> | {
        results: GraphOutputs;
    } | {
        successful: boolean;
        error?: string | Error | undefined;
    } | {
        id: string;
        value: ScalarOrArrayDataValue;
        processId: ProcessId;
    } | {
        graph: NodeGraph;
        inputs: GraphInputs;
    } | {
        graph: NodeGraph;
        outputs: GraphOutputs;
    } | {
        graph: NodeGraph;
        error: string | Error;
    } | {
        node: ChartNode;
        inputs: Inputs;
        processId: ProcessId;
    } | {
        node: ChartNode;
        outputs: Outputs;
        processId: ProcessId;
    } | {
        node: ChartNode;
        error: string | Error;
        processId: ProcessId;
    } | {
        successful: boolean;
        graph: NodeGraph;
        error?: string | Error | undefined;
    } | {
        node: ChartNode;
        processId: ProcessId;
        inputs: Inputs;
        outputs: Outputs;
        reason: string;
    } | {
        node: UserInputNode;
        inputs: Inputs;
        callback: (values: StringArrayDataValue) => void;
        processId: ProcessId;
    } | {
        node: ChartNode;
        outputs: Outputs;
        index: number;
        processId: ProcessId;
    } | {
        node: ChartNode;
        processId?: ProcessId | undefined;
    } | {
        error: string | Error;
    } | {
        project: Project;
        startGraph: NodeGraph;
        inputs: GraphInputs;
        contextValues: Record<string, DataValue>;
    } | AbortController | undefined) => void | Promise<void>) => import("emittery").UnsubscribeFunction;
    offAny: (listener: (eventName: "done" | "error" | "userInput" | `userEvent:${string}` | `globalSet:${string}` | "start" | "graphStart" | "graphError" | "graphFinish" | "graphAbort" | "nodeStart" | "nodeFinish" | "nodeError" | "nodeExcluded" | "partialOutput" | "nodeOutputsCleared" | "abort" | "finish" | "trace" | "pause" | "resume" | "globalSet" | "newAbortController", eventData: string | void | import("./DataValue.js").StringDataValue | import("./DataValue.js").NumberDataValue | import("./DataValue.js").DateDataValue | import("./DataValue.js").TimeDataValue | import("./DataValue.js").DateTimeDataValue | import("./DataValue.js").BoolDataValue | import("./DataValue.js").ChatMessageDataValue | ControlFlowExcludedDataValue | AnyDataValue | import("./DataValue.js").ObjectDataValue | import("./DataValue.js").GptFunctionDataValue | import("./DataValue.js").VectorDataValue | import("./DataValue.js").ImageDataValue | import("./DataValue.js").BinaryDataValue | import("./DataValue.js").AudioDataValue | ArrayDataValue<import("./DataValue.js").StringDataValue> | ArrayDataValue<import("./DataValue.js").NumberDataValue> | ArrayDataValue<import("./DataValue.js").BoolDataValue> | ArrayDataValue<import("./DataValue.js").ObjectDataValue> | ArrayDataValue<import("./DataValue.js").DateDataValue> | ArrayDataValue<import("./DataValue.js").TimeDataValue> | ArrayDataValue<import("./DataValue.js").DateTimeDataValue> | ArrayDataValue<import("./DataValue.js").ChatMessageDataValue> | ArrayDataValue<ControlFlowExcludedDataValue> | ArrayDataValue<AnyDataValue> | ArrayDataValue<import("./DataValue.js").GptFunctionDataValue> | ArrayDataValue<import("./DataValue.js").VectorDataValue> | ArrayDataValue<import("./DataValue.js").ImageDataValue> | ArrayDataValue<import("./DataValue.js").BinaryDataValue> | ArrayDataValue<import("./DataValue.js").AudioDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").StringDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").NumberDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").BoolDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").ObjectDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").DateDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").TimeDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").DateTimeDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").ChatMessageDataValue> | import("./DataValue.js").FunctionDataValue<ControlFlowExcludedDataValue> | import("./DataValue.js").FunctionDataValue<AnyDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").GptFunctionDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").VectorDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").ImageDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").BinaryDataValue> | import("./DataValue.js").FunctionDataValue<import("./DataValue.js").AudioDataValue> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").StringDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").NumberDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").BoolDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").ObjectDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").DateDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").TimeDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").DateTimeDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").ChatMessageDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<ControlFlowExcludedDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<AnyDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").GptFunctionDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").VectorDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").ImageDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").BinaryDataValue>> | import("./DataValue.js").FunctionDataValue<ArrayDataValue<import("./DataValue.js").AudioDataValue>> | {
        results: GraphOutputs;
    } | {
        successful: boolean;
        error?: string | Error | undefined;
    } | {
        id: string;
        value: ScalarOrArrayDataValue;
        processId: ProcessId;
    } | {
        graph: NodeGraph;
        inputs: GraphInputs;
    } | {
        graph: NodeGraph;
        outputs: GraphOutputs;
    } | {
        graph: NodeGraph;
        error: string | Error;
    } | {
        node: ChartNode;
        inputs: Inputs;
        processId: ProcessId;
    } | {
        node: ChartNode;
        outputs: Outputs;
        processId: ProcessId;
    } | {
        node: ChartNode;
        error: string | Error;
        processId: ProcessId;
    } | {
        successful: boolean;
        graph: NodeGraph;
        error?: string | Error | undefined;
    } | {
        node: ChartNode;
        processId: ProcessId;
        inputs: Inputs;
        outputs: Outputs;
        reason: string;
    } | {
        node: UserInputNode;
        inputs: Inputs;
        callback: (values: StringArrayDataValue) => void;
        processId: ProcessId;
    } | {
        node: ChartNode;
        outputs: Outputs;
        index: number;
        processId: ProcessId;
    } | {
        node: ChartNode;
        processId?: ProcessId | undefined;
    } | {
        error: string | Error;
    } | {
        project: Project;
        startGraph: NodeGraph;
        inputs: GraphInputs;
        contextValues: Record<string, DataValue>;
    } | AbortController | undefined) => void | Promise<void>) => void;
    onUserEvent(onEvent: string, listener: (event: DataValue | undefined) => void): void;
    offUserEvent(listener: (data: DataValue | undefined) => void): void;
    userInput(nodeId: NodeId, values: StringArrayDataValue): void;
    setExternalFunction(name: string, fn: ExternalFunction): void;
    abort(successful?: boolean, error?: Error | string): Promise<void>;
    pause(): void;
    resume(): void;
    setSlowMode(slowMode: boolean): void;
    events(): AsyncGenerator<ProcessEvent>;
    replayRecording(recorder: ExecutionRecorder): Promise<GraphOutputs>;
    /** Main function for running a graph. Runs a graph and returns the outputs from the output nodes of the graph. */
    processGraph(
    /** Required and optional context available to the nodes and all subgraphs. */
    context: ProcessContext, 
    /** Inputs to the main graph. You should pass all inputs required by the GraphInputNodes of the graph. */
    inputs?: Record<string, DataValue>, 
    /** Contextual data available to all graphs and subgraphs. Kind of like react context, avoids drilling down data into subgraphs. Be careful when using it. */
    contextValues?: Record<string, DataValue>): Promise<GraphOutputs>;
    getRootProcessor(): GraphProcessor;
    /** Raise a user event on the processor, all subprocessors, and their children. */
    raiseEvent(event: string, data: DataValue): void;
}
