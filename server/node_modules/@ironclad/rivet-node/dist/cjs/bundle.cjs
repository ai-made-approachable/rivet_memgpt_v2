"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  DebuggerDatasetProvider: () => DebuggerDatasetProvider,
  NodeDatasetProvider: () => NodeDatasetProvider,
  NodeNativeApi: () => NodeNativeApi,
  createProcessor: () => createProcessor,
  currentDebuggerState: () => currentDebuggerState,
  loadProjectAndAttachedDataFromFile: () => loadProjectAndAttachedDataFromFile,
  loadProjectFromFile: () => loadProjectFromFile,
  runGraph: () => runGraph,
  runGraphInFile: () => runGraphInFile,
  startDebuggerServer: () => startDebuggerServer
});
module.exports = __toCommonJS(src_exports);
__reExport(src_exports, require("@ironclad/rivet-core"), module.exports);

// src/native/NodeNativeApi.ts
var import_promises = require("node:fs/promises");
var import_node_fs = require("node:fs");
var import_node_path = require("node:path");
var import_rivet_core = require("@ironclad/rivet-core");
var import_minimatch = require("minimatch");
async function* walk(dir) {
  for await (const d of await (0, import_promises.opendir)(dir)) {
    const entry = (0, import_node_path.join)(dir, d.name);
    if (d.isDirectory())
      yield* walk(entry);
    else if (d.isFile())
      yield entry;
  }
}
var NodeNativeApi = class {
  async readdir(path, baseDir, options = {}) {
    const {
      recursive = false,
      includeDirectories = false,
      filterGlobs = [],
      relative: isRelative = false,
      ignores = []
    } = options;
    let results = [];
    if (recursive) {
      for await (const entry of walk(path)) {
        results.push(entry);
      }
    } else {
      const dirents = await (0, import_promises.readdir)(path, { withFileTypes: true });
      results = dirents.map((dirent) => (0, import_node_path.join)(path, dirent.name));
    }
    if (!includeDirectories) {
      results = results.filter((result) => (0, import_node_fs.lstatSync)(result).isFile());
    }
    if (filterGlobs.length > 0) {
      for (const glob of filterGlobs) {
        results = results.filter((result) => (0, import_minimatch.minimatch)(result, glob, { dot: true }));
      }
    }
    if (ignores.length > 0) {
      for (const ignore of ignores) {
        results = results.filter((result) => !(0, import_minimatch.minimatch)(result, ignore, { dot: true }));
      }
    }
    if (isRelative) {
      results = results.map((result) => (0, import_node_path.relative)(path, result));
    }
    return results;
  }
  async readTextFile(path, baseDir) {
    const result = await (0, import_promises.readFile)(path, "utf-8");
    return result;
  }
  async readBinaryFile(path, baseDir) {
    const result = await (0, import_promises.readFile)(path);
    return new Blob([result]);
  }
  async writeTextFile(path, data, baseDir) {
    await (0, import_promises.writeFile)(path, data, "utf-8");
  }
  exec(command, args, options) {
    throw new Error("Not Implemented");
  }
};

// src/api.ts
var import_rivet_core2 = require("@ironclad/rivet-core");
var import_promises2 = require("node:fs/promises");
var events = __toESM(require("node:events"), 1);
async function loadProjectFromFile(path) {
  const content = await (0, import_promises2.readFile)(path, { encoding: "utf8" });
  return (0, import_rivet_core2.loadProjectFromString)(content);
}
async function loadProjectAndAttachedDataFromFile(path) {
  const content = await (0, import_promises2.readFile)(path, { encoding: "utf8" });
  return (0, import_rivet_core2.loadProjectAndAttachedDataFromString)(content);
}
async function runGraphInFile(path, options) {
  const project = await loadProjectFromFile(path);
  return runGraph(project, options);
}
function createProcessor(project, options) {
  const processor = (0, import_rivet_core2.coreCreateProcessor)(project, options);
  processor.processor.executor = "nodejs";
  processor.processor.on("newAbortController", (controller) => {
    events.setMaxListeners(100, controller.signal);
  });
  if (options.remoteDebugger) {
    options.remoteDebugger.attach(processor.processor);
  }
  let pluginEnv = options.pluginEnv;
  if (!pluginEnv) {
    pluginEnv = getPluginEnvFromProcessEnv(options.registry);
  }
  return {
    ...processor,
    async run() {
      const outputs = await processor.processor.processGraph(
        {
          nativeApi: options.nativeApi ?? new NodeNativeApi(),
          datasetProvider: options.datasetProvider,
          settings: {
            openAiKey: options.openAiKey ?? process.env.OPENAI_API_KEY ?? "",
            openAiOrganization: options.openAiOrganization ?? process.env.OPENAI_ORG_ID ?? "",
            openAiEndpoint: options.openAiEndpoint ?? process.env.OPENAI_ENDPOINT ?? "",
            pluginEnv: pluginEnv ?? {},
            pluginSettings: options.pluginSettings ?? {},
            recordingPlaybackLatency: 1e3,
            chatNodeHeaders: options.chatNodeHeaders ?? {},
            chatNodeTimeout: options.chatNodeTimeout ?? import_rivet_core2.DEFAULT_CHAT_NODE_TIMEOUT
          },
          getChatNodeEndpoint: options.getChatNodeEndpoint
        },
        processor.inputs,
        processor.contextValues
      );
      return outputs;
    }
  };
}
async function runGraph(project, options) {
  const processorInfo = createProcessor(project, options);
  return processorInfo.run();
}
function getPluginEnvFromProcessEnv(registry) {
  const pluginEnv = {};
  for (const plugin of (registry ?? import_rivet_core2.globalRivetNodeRegistry).getPlugins() ?? []) {
    const configs = Object.entries(plugin.configSpec ?? {}).filter(([, c]) => c.type === "string");
    for (const [configName, config] of configs) {
      if (config.pullEnvironmentVariable) {
        const envVarName = typeof config.pullEnvironmentVariable === "string" ? config.pullEnvironmentVariable : config.pullEnvironmentVariable === true ? configName : void 0;
        if (envVarName) {
          pluginEnv[envVarName] = process.env[envVarName] ?? "";
        }
      }
    }
  }
  return pluginEnv;
}

// src/debugger.ts
var import_ws = __toESM(require("ws"), 1);
var import_rivet_core3 = require("@ironclad/rivet-core");
var import_ts_pattern = require("ts-pattern");
var import_emittery = __toESM(require("emittery-0-13"), 1);
var currentDebuggerState = {
  uploadedProject: void 0,
  settings: void 0
};
function startDebuggerServer(options = {}) {
  const { port = 21888, throttlePartialOutputs = 100, host = "localhost" } = options;
  const server = options.server ?? new import_ws.WebSocketServer({ port, host });
  const emitter = new import_emittery.default();
  const attachedProcessors = [];
  server.on("connection", (socket) => {
    if (options.datasetProvider) {
      options.datasetProvider.onrequest = (type, data) => {
        socket.send(
          JSON.stringify({
            message: type,
            data
          })
        );
      };
    }
    socket.on("message", async (data) => {
      try {
        const stringData = data.toString();
        if (stringData.startsWith("set-static-data:")) {
          const [, id, value] = stringData.split(":");
          if (currentDebuggerState.uploadedProject) {
            currentDebuggerState.uploadedProject.data ??= {};
            currentDebuggerState.uploadedProject.data[id] = value;
          }
          return;
        }
        const message = JSON.parse(data.toString());
        await (0, import_ts_pattern.match)(message).with({ type: "run" }, async () => {
          var _a;
          const { graphId, inputs, runToNodeIds, contextValues } = message.data;
          await ((_a = options.dynamicGraphRun) == null ? void 0 : _a.call(options, { client: socket, graphId, inputs, runToNodeIds, contextValues }));
        }).with({ type: "set-dynamic-data" }, async () => {
          if (options.allowGraphUpload) {
            const { project, settings, datasets } = message.data;
            currentDebuggerState.uploadedProject = project;
            currentDebuggerState.settings = settings;
          }
        }).with({ type: "datasets:response" }, async () => {
          var _a;
          (_a = options.datasetProvider) == null ? void 0 : _a.handleResponse(message.type, message.data);
        }).otherwise(async () => {
          var _a;
          const processors = ((_a = options.getProcessorsForClient) == null ? void 0 : _a.call(options, socket, attachedProcessors)) ?? attachedProcessors;
          for (const processor of processors) {
            await (0, import_ts_pattern.match)(message).with({ type: "abort" }, async () => {
              await processor.abort();
            }).with({ type: "pause" }, async () => {
              processor.pause();
            }).with({ type: "resume" }, async () => {
              processor.resume();
            }).with({ type: "user-input" }, async () => {
              const { nodeId, answers } = message.data;
              processor.userInput(nodeId, answers);
            }).otherwise(async () => {
              throw new Error(`Unknown message type: ${message.type}`);
            });
          }
        });
      } catch (err) {
        try {
          await emitter.emit("error", (0, import_rivet_core3.getError)(err));
        } catch (err2) {
        }
      }
    });
    if (options.allowGraphUpload) {
      socket.send(
        JSON.stringify({
          message: "graph-upload-allowed",
          data: {}
        })
      );
    }
  });
  return {
    on: emitter.on.bind(emitter),
    off: emitter.off.bind(emitter),
    webSocketServer: server,
    /** Given an event on a processor, sends that processor's events to the correct debugger clients (allows routing debugger). */
    broadcast(procesor, message, data) {
      var _a;
      const clients = ((_a = options.getClientsForProcessor) == null ? void 0 : _a.call(options, procesor, [...server.clients])) ?? [...server.clients];
      clients.forEach((client) => {
        if (client.readyState === import_ws.default.OPEN) {
          client.send(JSON.stringify({ message, data }));
        }
      });
    },
    attach(processor) {
      if (attachedProcessors.find((p) => p.id === processor.id)) {
        return;
      }
      const lastPartialOutputsTimePerNode = {};
      attachedProcessors.push(processor);
      processor.on("nodeStart", (data) => {
        this.broadcast(processor, "nodeStart", data);
      });
      processor.on("nodeFinish", (data) => {
        this.broadcast(processor, "nodeFinish", data);
      });
      processor.on("nodeError", ({ node, error, processId }) => {
        this.broadcast(processor, "nodeError", {
          node,
          error: typeof error === "string" ? error : error.toString(),
          processId
        });
      });
      processor.on("error", ({ error }) => {
        this.broadcast(processor, "error", {
          error: typeof error === "string" ? error : error.toString()
        });
      });
      processor.on("graphError", ({ graph, error }) => {
        this.broadcast(processor, "graphError", {
          graph,
          error: typeof error === "string" ? error : error.toString()
        });
      });
      processor.on("nodeExcluded", (data) => {
        this.broadcast(processor, "nodeExcluded", data);
      });
      processor.on("start", (data) => {
        this.broadcast(processor, "start", data);
      });
      processor.on("done", (data) => {
        this.broadcast(processor, "done", data);
      });
      processor.on("partialOutput", (data) => {
        if (lastPartialOutputsTimePerNode[data.node.id] == null || (lastPartialOutputsTimePerNode[data.node.id] ?? 0) + throttlePartialOutputs < Date.now()) {
          this.broadcast(processor, "partialOutput", data);
          lastPartialOutputsTimePerNode[data.node.id] = Date.now();
        }
      });
      processor.on("abort", () => {
        this.broadcast(processor, "abort", null);
      });
      processor.on("graphAbort", (data) => {
        this.broadcast(processor, "graphAbort", data);
      });
      processor.on("trace", (message) => {
        this.broadcast(processor, "trace", message);
      });
      processor.on("nodeOutputsCleared", (data) => {
        this.broadcast(processor, "nodeOutputsCleared", data);
      });
      processor.on("graphStart", (data) => {
        this.broadcast(processor, "graphStart", data);
      });
      processor.on("graphFinish", (data) => {
        this.broadcast(processor, "graphFinish", data);
      });
      processor.on("pause", () => {
        this.broadcast(processor, "pause", null);
      });
      processor.on("resume", () => {
        this.broadcast(processor, "resume", null);
      });
      processor.on("userInput", (data) => {
        this.broadcast(processor, "userInput", data);
      });
    },
    detach(processor) {
      const processorIndex = attachedProcessors.findIndex((p) => p.id === processor.id);
      if (processorIndex !== -1) {
        attachedProcessors.splice(processorIndex, 1);
      }
    }
  };
}

// src/native/NodeDatasetProvider.ts
var import_rivet_core4 = require("@ironclad/rivet-core");
var import_promises3 = require("node:fs/promises");
var NodeDatasetProvider = class _NodeDatasetProvider extends import_rivet_core4.InMemoryDatasetProvider {
  #save;
  #filePath;
  constructor(datasets, options = {}) {
    super(datasets);
    const { save = false, filePath } = options;
    this.#filePath = filePath;
    this.#save = save;
    if (save && !filePath) {
      throw new Error("Cannot save datasets without a file path");
    }
  }
  static async fromDatasetsFile(datasetsFilePath, options = {}) {
    try {
      const fileContents = await (0, import_promises3.readFile)(datasetsFilePath, "utf8");
      const datasets = (0, import_rivet_core4.deserializeDatasets)(fileContents);
      return new _NodeDatasetProvider(datasets, {
        save: options.save,
        filePath: datasetsFilePath
      });
    } catch (err) {
      const { requireFile = false } = options;
      if (err.code === "ENOENT") {
        if (requireFile) {
          throw new Error(`No datasets file found at ${datasetsFilePath}`);
        } else {
          return new _NodeDatasetProvider([], {
            save: options.save,
            filePath: datasetsFilePath
          });
        }
      }
      throw err;
    }
  }
  static async fromProjectFile(projectFilePath, options = {}) {
    const dataFilePath = projectFilePath.replace(/\.rivet-project$/, ".rivet-data");
    return _NodeDatasetProvider.fromDatasetsFile(dataFilePath, options);
  }
  async save() {
    if (!this.#save) {
      return;
    }
    const exported = await this.exportDatasetsForProject("");
    const serialized = (0, import_rivet_core4.serializeDatasets)(exported);
    if (!this.#filePath) {
      throw new Error("Cannot save datasets without a file path");
    }
    await (0, import_promises3.writeFile)(this.#filePath, serialized, "utf8");
  }
  async putDatasetData(id, data) {
    await super.putDatasetData(id, data);
    await this.save();
  }
  async putDatasetMetadata(metadata) {
    await super.putDatasetMetadata(metadata);
    await this.save();
  }
  async putDatasetRow(id, row) {
    await super.putDatasetRow(id, row);
    await this.save();
  }
  async clearDatasetData(id) {
    await super.clearDatasetData(id);
    await this.save();
  }
  async deleteDataset(id) {
    await super.deleteDataset(id);
    await this.save();
  }
};

// src/native/DebuggerDatasetProvider.ts
var import_rivet_core5 = require("@ironclad/rivet-core");
var DebuggerDatasetProvider = class {
  listeners = {};
  onrequest;
  handleResponse(type, data) {
    const { requestId, payload } = data;
    if (type === "datasets:response") {
      const listener = this.listeners[requestId];
      if (listener) {
        listener(payload);
      }
    }
  }
  makeRequestAndWaitForResponse(type, data) {
    var _a;
    const requestId = (0, import_rivet_core5.newId)();
    const waitingPromise = new Promise((resolve) => {
      this.listeners[requestId] = (response) => {
        delete this.listeners[requestId];
        resolve(response);
      };
    });
    (_a = this.onrequest) == null ? void 0 : _a.call(this, type, { requestId, payload: data });
    return waitingPromise;
  }
  getDatasetMetadata(id) {
    return this.makeRequestAndWaitForResponse(`datasets:get-metadata`, { id });
  }
  getDatasetsForProject(projectId) {
    return this.makeRequestAndWaitForResponse(`datasets:get-for-project`, { projectId });
  }
  getDatasetData(id) {
    return this.makeRequestAndWaitForResponse(`datasets:get-data`, { id });
  }
  putDatasetData(id, data) {
    return this.makeRequestAndWaitForResponse(`datasets:put-data`, { id, data });
  }
  putDatasetRow(id, row) {
    return this.makeRequestAndWaitForResponse(`datasets:put-row`, { id, row });
  }
  putDatasetMetadata(metadata) {
    return this.makeRequestAndWaitForResponse(`datasets:put-metadata`, { metadata });
  }
  clearDatasetData(id) {
    return this.makeRequestAndWaitForResponse(`datasets:clear-data`, { id });
  }
  deleteDataset(id) {
    return this.makeRequestAndWaitForResponse(`datasets:delete`, { id });
  }
  knnDatasetRows(datasetId, k, vector) {
    return this.makeRequestAndWaitForResponse(`datasets:knn`, { datasetId, k, vector });
  }
  exportDatasetsForProject(projectId) {
    return this.makeRequestAndWaitForResponse(`datasets:export-for-project`, { projectId });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DebuggerDatasetProvider,
  NodeDatasetProvider,
  NodeNativeApi,
  createProcessor,
  currentDebuggerState,
  loadProjectAndAttachedDataFromFile,
  loadProjectFromFile,
  runGraph,
  runGraphInFile,
  startDebuggerServer,
  ...require("@ironclad/rivet-core")
});
